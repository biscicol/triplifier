#summary Information for software developers who would like to use the triplifier.
#labels Featured,Phase-Implementation

==Introduction==

There are at least two ways in which software developers might want to interact with the [http://biscicol.blogspot.com/ BiSciCol] triplifier.  First, programmers can extend the number of input formats supported by the triplifier by writing new reader plugins.  Second, the triplifier's reader system can also be used as a component of other software projects.    This document discusses both writing new reader plugins and using the triplifier in other software.

==Writing new reader plugins==

As distributed, the core triplifier supports a relatively small number of file formats, including CSV files, [http://www.openoffice.org/ OpenOffice] spreadsheets, Excel spreadsheets, and [http://rs.tdwg.org/dwc/terms/guides/text/index.htm Darwin Core Text] archives.  Each of these formats is implemented as a separate reader plugin.  Rather than try to anticipate every input format that researchers might want to use, we have tried to make it easy to write new reader plugins.

All plugins must support the !TabularDataReader interface, which is part of the "reader.plugins" package in the triplifier source code.  The plugins do not have any other dependencies or requirements.  Each method required by the !TabularDataReader interface is described in detailed javadoc comments in the interface source file.

To illustrate the process, we will go through the initial steps of writing a reader plugin for CSV files.  The basic skeleton of the reader plugin will be as follows.
{{{
package plugins;

public class CSVReader implements TabularDataReader
{
    /* Add implementations for all interface methods here. */
}
}}}

Next, we'll add an implementation of getFormatString().  This method is used to return a short string that acts as a constant, identifying the file format(s) supported by the reader.  It should be unique, at least in comparison to the other reader plugins that are installed.  We'll just use "CSV" as the identifier.
{{{
    @Override
    public String getFormatString() {
        return "CSV";
    }
}}}

The methods getFormatDescription() and getShortFormatDesc() are used to provide human-readable descriptions of the input formats supported by the reader.  The short description should be usable in space-constrained settings, such as file chooser dialogs.  The longer description can be more informative.
{{{
    @Override
    public String getShortFormatDesc() {
        return "CSV";
    }

    @Override
    public String getFormatDescription() {
        return "comma-separated values";
    }
}}}

We'll next implement getFileExtensions() to indicate the file extensions we expect on valid input files.  This will mostly be useful to user interface code, such as file chooser dialogs.  Some input formats use multiple file extensions (e.g., Excel files can be either "xls" or "xlsx"), so the method returns an array of Strings.
{{{
    @Override
    public String[] getFileExtensions() {
        return new String[] {"csv"};
    }
}}}

The remaining methods implement the "guts" of the plugin that handle opening files and reading data from them.  !TabularDataReader considers a data source to consist of one or more "tables" of data, and provides methods to iterate through all of the tables in a data source.  Thus, even though a CSV file represents a single table of data, !TabularDataReader also supports data sources with multiple "tables" of data, such as spreadsheet files with more than one worksheet.  Rows in a table are returned one at a time.  Each row must be returned as an array of Strings, where each element of the array corresponds to one column in the source format.

Rather than take the space to illustrate full implementations of the remaining !TabularDataReader methods here, please refer to the javadoc documentation of !TabularDataReader, as well as the source code of the reader plugins provided with the triplifier.

Once the reader plugin is fully implemented and compiled, the compiled .class file must be placed in the "plugins" directory of the compiled triplifier code.  That is all that is required to "install" the new plugin.  The triplifier will automatically detect and load the new plugin the next time it is run.

Finally, although this discussion has focused on writing plugins for file-based input data, this is not a requirement.  Reader plugins could just as well be written for input data that is accessed from a Web service, for example.

== Using the triplifier in other software ==

Accessing the server-side triplifier components from other Java software is straightforward.  To use the reader system, you will need an instance of !ReaderManager.  !ReaderManager handles finding and loading all available plugins and provides an interface for getting reader objects to process input data sources.  Although individual reader plugins could also be instantiated directly, using a !ReaderManager is recommended.

===Initializing the !ReaderManager and processing input files===

After instantiating a !ReaderManager, you will need to tell it to search for and load any available reader plugins.
{{{
ReaderManager rm = new ReaderManager();
try {
    rm.LoadReaders();
}
catch (FileNotFoundException e) { /* Handle the exception... */ }
}}}

You can then open a data file and loop through each of its data tables one row at a time.  To open a file, you can either request a specific reader from the !ReaderManager using getReader(), or simply call openFile(), which will automatically determine the appropriate reader for the specified file.
{{{
TabularDataReader reader = rm.openFile("/path/to/data/file");

String[] row;
while (reader.hasNextTable()) {
    reader.moveToNextTable();

    while (reader.hasNextRow())
    {
        row = reader.getNextRow();
        /* Code to process the data... */
    }
}
}}}

===Converting input data to a SQLite database===

The triplifier uses a [http://www.sqlite.org/ SQLite] database as an intermediate format for incoming data prior to passing it off to [http://www4.wiwiss.fu-berlin.de/bizer/d2rq/ D2RQ].  Thus, all input sources that are not already relational databases are first converted to tables in a SQLite database.

To access this functionality, use !TabularDataConverter.  You will need to provide the !TabularDataConverter with a valid !TabularDataReader (usually obtained from a !ReaderManager, as described above) and a SQLite JDBC connection string.  Then simply call the convert() method of !TabularDataConverter and it will read all source data and store it in the SQLite database.  A simple example follows.
{{{
/* We assume that rm is a reference to a ReaderManager. */

try {
    TabularDataConverter tdc = new TabularDataConverter(
    rm.openFile("test.csv"), "jdbc:sqlite:tempdb.sqlite");
        
    tdc.convert();
} catch (Exception e) {
    /* Handle the exception.  You will probably want to use multiple catch clauses for each possible exception. */
}